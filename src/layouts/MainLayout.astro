---
import siteData from "../data/site.json";
import "../styles/global.css";
import "aos/dist/aos.css";
---

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RezCode - Premium Digital Solutions</title>
    <meta
      name="description"
      content="RezCode delivers cutting-edge web solutions with futuristic design and unmatched performance."
    />
    <meta name="theme-color" content="#0c0f19" />

    <!-- Favicon -->
    <link rel="icon" type="image/png" href={siteData.logo} />
    <link rel="apple-touch-icon" href={siteData.logo} />

    <!-- Performance: Preconnect & Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&display=swap"
      rel="stylesheet"
      media="print"
      onload="this.media='all'"
    />
    <link
      rel="preload"
      href="https://fonts.gstatic.com/s/outfit/v11/QGYsz_ueSjtS_O7xMA.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />

    <!-- Critical CSS: Inlined to prevent blocking -->
    <style is:inline>
      :root {
        --color-brand-dark: #0c0f19;
        --color-brand-primary: #3b65a4;
        --color-brand-secondary: #4080bf;
        --color-brand-light: #f8fbfd;
      }
      body {
        background: #0c0f19;
        color: #f8fbfd;
        font-family: "Outfit", sans-serif;
        margin: 0;
      }

      @keyframes gradient {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }

      .animate-gradient {
        background-size: 200% auto;
        animation: gradient 3s linear infinite;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0) rotate(0deg);
        }
        50% {
          transform: translateY(-20px) rotate(2deg);
        }
      }

      .animate-float-delayed {
        animation: float 6s ease-in-out infinite;
        animation-delay: 3s;
      }
    </style>

    <link rel="preload" href="/logo.png" as="image" />
    <link rel="manifest" href="/manifest.json" />
    <script is:inline>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("/sw.js");
        });
      }
    </script>
  </head>
  <body
    class="bg-brand-dark text-brand-light min-h-screen selection:bg-brand-primary selection:text-white"
  >
    <slot />

    <script>
      import AOS from "aos";

      // Initialize AOS after a short delay to prioritize LCP
      window.addEventListener("load", () => {
        setTimeout(() => {
          AOS.init({
            duration: 400,
            easing: "ease-out-cubic",
            once: true,
            mirror: false,
            offset: 50,
            disable: "mobile",
          });
        }, 100);
      });

      // Global Optimized Mouse Tracking for Glow Cards
      // Only enable on fine pointers (mouse) to save energy on tablets/phones
      const isTouch = window.matchMedia("(pointer: coarse)").matches;

      if (!isTouch) {
        let frameRequested = false;
        let cards: { el: HTMLElement; rect: DOMRect }[] = [];

        // Use IntersectionObserver to only track cards in viewport
        const observerOptions = {
          root: null,
          threshold: 0,
        };

        const cardObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            const el = entry.target as HTMLElement;
            if (entry.isIntersecting) {
              // Cache rect on intersection to avoid getBoundingClientRect in mousemove
              cards.push({ el, rect: el.getBoundingClientRect() });
            } else {
              cards = cards.filter((c) => c.el !== el);
            }
          });
        }, observerOptions);

        const updateCardCache = () => {
          document.querySelectorAll(".glow-card").forEach((card) => {
            cardObserver.observe(card);
          });
        };

        updateCardCache();

        // Refresh rects on scroll or resize with throttling
        let scrollTimeout: any;
        window.addEventListener(
          "scroll",
          () => {
            if (scrollTimeout) return;
            scrollTimeout = setTimeout(() => {
              cards.forEach((c) => {
                c.rect = c.el.getBoundingClientRect();
              });
              scrollTimeout = null;
            }, 100); // Throttle to 100ms
          },
          { passive: true },
        );

        window.addEventListener(
          "resize",
          () => {
            cards.forEach((c) => {
              c.rect = c.el.getBoundingClientRect();
            });
          },
          { passive: true },
        );

        const domObserver = new MutationObserver(updateCardCache);
        domObserver.observe(document.body, { childList: true, subtree: true });

        document.addEventListener("mousemove", (e) => {
          if (frameRequested || cards.length === 0) return;
          frameRequested = true;

          requestAnimationFrame(() => {
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // PERFORMANCE: No getBoundingClientRect() here!
            cards.forEach((card) => {
              const x = mouseX - card.rect.left;
              const y = mouseY - card.rect.top;
              card.el.style.setProperty("--mouse-x", `${x}px`);
              card.el.style.setProperty("--mouse-y", `${y}px`);
            });
            frameRequested = false;
          });
        });
      }

      // Click Ripple Effect
      document.addEventListener("click", (e) => {
        const ripple = document.createElement("div");
        ripple.classList.add("ripple");

        const size = 100;
        ripple.style.width = `${size}px`;
        ripple.style.height = `${size}px`;
        ripple.style.left = `${e.clientX - size / 2}px`;
        ripple.style.top = `${e.clientY - size / 2}px`;

        document.body.appendChild(ripple);

        setTimeout(() => {
          ripple.remove();
        }, 800);
      });
    </script>
  </body>
</html>
